{"ast":null,"code":"import { __rest } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useEffect, useImperativeHandle, useLayoutEffect, useRef, useState } from 'react';\nimport { useStableCallback } from '@cloudscape-design/component-toolkit/internal';\nimport ScreenreaderOnly from '../../internal/components/screenreader-only';\nimport { fireNonCancelableEvent } from '../../internal/events';\nimport { useControllable } from '../../internal/hooks/use-controllable';\nimport { useIntersectionObserver } from '../../internal/hooks/use-intersection-observer';\nimport { useMergeRefs } from '../../internal/hooks/use-merge-refs';\nimport { useMobile } from '../../internal/hooks/use-mobile';\nimport { useUniqueId } from '../../internal/hooks/use-unique-id';\nimport { useGetGlobalBreadcrumbs } from '../../internal/plugins/helpers/use-global-breadcrumbs';\nimport globalVars from '../../internal/styles/global-vars';\nimport { getSplitPanelDefaultSize } from '../../split-panel/utils/size-utils';\nimport { MIN_DRAWER_SIZE, useDrawers } from '../utils/use-drawers';\nimport { useFocusControl, useMultipleFocusControl } from '../utils/use-focus-control';\nimport { useSplitPanelFocusControl } from '../utils/use-split-panel-focus-control';\nimport { ActiveDrawersContext } from '../utils/visibility-context';\nimport { computeHorizontalLayout, computeVerticalLayout, CONTENT_PADDING } from './compute-layout';\nimport { AppLayoutVisibilityContext } from './contexts';\nimport { AppLayoutDrawer, AppLayoutGlobalDrawers, AppLayoutNavigation, AppLayoutNotifications, AppLayoutSplitPanelBottom, AppLayoutSplitPanelSide, AppLayoutToolbar } from './internal';\nimport { useMultiAppLayout } from './multi-layout';\nimport { SkeletonLayout } from './skeleton';\nconst AppLayoutVisualRefreshToolbar = React.forwardRef((_a, forwardRef) => {\n  var _b, _c;\n  var {\n      ariaLabels,\n      contentHeader,\n      content,\n      navigationOpen,\n      navigationWidth,\n      navigation,\n      navigationHide,\n      onNavigationChange,\n      tools,\n      toolsOpen: controlledToolsOpen,\n      onToolsChange,\n      toolsHide,\n      toolsWidth,\n      contentType,\n      headerVariant,\n      breadcrumbs,\n      notifications,\n      stickyNotifications,\n      splitPanelPreferences: controlledSplitPanelPreferences,\n      splitPanelOpen: controlledSplitPanelOpen,\n      splitPanel,\n      splitPanelSize: controlledSplitPanelSize,\n      onSplitPanelToggle,\n      onSplitPanelResize,\n      onSplitPanelPreferencesChange,\n      disableContentPaddings,\n      minContentWidth,\n      maxContentWidth,\n      placement\n    } = _a,\n    rest = __rest(_a, [\"ariaLabels\", \"contentHeader\", \"content\", \"navigationOpen\", \"navigationWidth\", \"navigation\", \"navigationHide\", \"onNavigationChange\", \"tools\", \"toolsOpen\", \"onToolsChange\", \"toolsHide\", \"toolsWidth\", \"contentType\", \"headerVariant\", \"breadcrumbs\", \"notifications\", \"stickyNotifications\", \"splitPanelPreferences\", \"splitPanelOpen\", \"splitPanel\", \"splitPanelSize\", \"onSplitPanelToggle\", \"onSplitPanelResize\", \"onSplitPanelPreferencesChange\", \"disableContentPaddings\", \"minContentWidth\", \"maxContentWidth\", \"placement\"]);\n  const isMobile = useMobile();\n  const {\n    __embeddedViewMode: embeddedViewMode,\n    __forceDeduplicationType: forceDeduplicationType\n  } = rest;\n  const splitPanelControlId = useUniqueId('split-panel');\n  const [toolbarState, setToolbarState] = useState('show');\n  const [toolbarHeight, setToolbarHeight] = useState(0);\n  const [notificationsHeight, setNotificationsHeight] = useState(0);\n  const [navigationAnimationDisabled, setNavigationAnimationDisabled] = useState(true);\n  const [splitPanelAnimationDisabled, setSplitPanelAnimationDisabled] = useState(true);\n  const [isNested, setIsNested] = useState(false);\n  const rootRef = useRef(null);\n  const [toolsOpen = false, setToolsOpen] = useControllable(controlledToolsOpen, onToolsChange, false, {\n    componentName: 'AppLayout',\n    controlledProp: 'toolsOpen',\n    changeHandler: 'onToolsChange'\n  });\n  const onToolsToggle = open => {\n    setToolsOpen(open);\n    drawersFocusControl.setFocus();\n    fireNonCancelableEvent(onToolsChange, {\n      open\n    });\n  };\n  const onGlobalDrawerFocus = (drawerId, open) => {\n    globalDrawersFocusControl.setFocus({\n      force: true,\n      drawerId,\n      open\n    });\n  };\n  const onAddNewActiveDrawer = drawerId => {\n    var _a, _b;\n    // If a local drawer is already open, and we attempt to open a new one,\n    // it will replace the existing one instead of opening an additional drawer,\n    // since only one local drawer is supported. Therefore, layout calculations are not necessary.\n    if (activeDrawer && (drawers === null || drawers === void 0 ? void 0 : drawers.find(drawer => drawer.id === drawerId))) {\n      return;\n    }\n    // get the size of drawerId. it could be either local or global drawer\n    const combinedDrawers = [...(drawers || []), ...globalDrawers];\n    const newDrawer = combinedDrawers.find(drawer => drawer.id === drawerId);\n    if (!newDrawer) {\n      return;\n    }\n    const newDrawerSize = Math.min((_b = (_a = newDrawer.defaultSize) !== null && _a !== void 0 ? _a : drawerSizes[drawerId]) !== null && _b !== void 0 ? _b : MIN_DRAWER_SIZE, MIN_DRAWER_SIZE);\n    //   check if the active drawers could be resized to fit the new drawers\n    //   to do this, we need to take all active drawers, sum up their min sizes, truncate it from resizableSpaceAvailable\n    //   and compare a given number with the new drawer id min size\n    // the total size of all global drawers resized to their min size\n    const availableSpaceForNewDrawer = resizableSpaceAvailable - totalActiveDrawersMinSize;\n    if (availableSpaceForNewDrawer >= newDrawerSize) {\n      return;\n    }\n    // now we made sure we cannot accommodate the new drawer with existing ones\n    closeFirstDrawer();\n  };\n  const {\n    drawers,\n    activeDrawer,\n    minDrawerSize,\n    minGlobalDrawersSizes,\n    activeDrawerSize,\n    ariaLabelsWithDrawers,\n    globalDrawers,\n    activeGlobalDrawers,\n    activeGlobalDrawersIds,\n    activeGlobalDrawersSizes,\n    drawerSizes,\n    drawersOpenQueue,\n    onActiveDrawerChange,\n    onActiveDrawerResize,\n    onActiveGlobalDrawersChange\n  } = useDrawers(Object.assign(Object.assign({}, rest), {\n    onGlobalDrawerFocus,\n    onAddNewActiveDrawer\n  }), ariaLabels, {\n    ariaLabels,\n    toolsHide,\n    toolsOpen,\n    tools,\n    toolsWidth,\n    onToolsToggle\n  });\n  const onActiveDrawerChangeHandler = (drawerId, params = {\n    initiatedByUserAction: true\n  }) => {\n    onActiveDrawerChange(drawerId, params);\n    drawersFocusControl.setFocus();\n  };\n  const [splitPanelOpen = false, setSplitPanelOpen] = useControllable(controlledSplitPanelOpen, onSplitPanelToggle, false, {\n    componentName: 'AppLayout',\n    controlledProp: 'splitPanelOpen',\n    changeHandler: 'onSplitPanelToggle'\n  });\n  const onSplitPanelToggleHandler = () => {\n    setSplitPanelAnimationDisabled(false);\n    setSplitPanelOpen(!splitPanelOpen);\n    splitPanelFocusControl.setLastInteraction({\n      type: splitPanelOpen ? 'close' : 'open'\n    });\n    fireNonCancelableEvent(onSplitPanelToggle, {\n      open: !splitPanelOpen\n    });\n  };\n  const [splitPanelPreferences, setSplitPanelPreferences] = useControllable(controlledSplitPanelPreferences, onSplitPanelPreferencesChange, undefined, {\n    componentName: 'AppLayout',\n    controlledProp: 'splitPanelPreferences',\n    changeHandler: 'onSplitPanelPreferencesChange'\n  });\n  const onSplitPanelPreferencesChangeHandler = detail => {\n    setSplitPanelPreferences(detail);\n    splitPanelFocusControl.setLastInteraction({\n      type: 'position'\n    });\n    fireNonCancelableEvent(onSplitPanelPreferencesChange, detail);\n  };\n  const [splitPanelSize = 0, setSplitPanelSize] = useControllable(controlledSplitPanelSize, onSplitPanelResize, getSplitPanelDefaultSize((_b = splitPanelPreferences === null || splitPanelPreferences === void 0 ? void 0 : splitPanelPreferences.position) !== null && _b !== void 0 ? _b : 'bottom'), {\n    componentName: 'AppLayout',\n    controlledProp: 'splitPanelSize',\n    changeHandler: 'onSplitPanelResize'\n  });\n  const [splitPanelReportedSize, setSplitPanelReportedSize] = useState(0);\n  const [splitPanelHeaderBlockSize, setSplitPanelHeaderBlockSize] = useState(0);\n  const onSplitPanelResizeHandler = size => {\n    setSplitPanelSize(size);\n    fireNonCancelableEvent(onSplitPanelResize, {\n      size\n    });\n  };\n  const [splitPanelToggleConfig, setSplitPanelToggleConfig] = useState({\n    ariaLabel: undefined,\n    displayed: false\n  });\n  const globalDrawersFocusControl = useMultipleFocusControl(true, activeGlobalDrawersIds);\n  const drawersFocusControl = useFocusControl(!!(activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.id), true, activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.id);\n  const navigationFocusControl = useFocusControl(navigationOpen);\n  const splitPanelFocusControl = useSplitPanelFocusControl([splitPanelPreferences, splitPanelOpen]);\n  const onNavigationToggle = useStableCallback(open => {\n    setNavigationAnimationDisabled(false);\n    navigationFocusControl.setFocus();\n    fireNonCancelableEvent(onNavigationChange, {\n      open\n    });\n  });\n  useImperativeHandle(forwardRef, () => ({\n    closeNavigationIfNecessary: () => isMobile && onNavigationToggle(false),\n    openTools: () => onToolsToggle(true),\n    focusToolsClose: () => drawersFocusControl.setFocus(true),\n    focusActiveDrawer: () => drawersFocusControl.setFocus(true),\n    focusSplitPanel: () => {\n      var _a;\n      return (_a = splitPanelFocusControl.refs.slider.current) === null || _a === void 0 ? void 0 : _a.focus();\n    }\n  }));\n  const resolvedStickyNotifications = !!stickyNotifications && !isMobile;\n  //navigation must be null if hidden so toolbar knows to hide the toggle button\n  const resolvedNavigation = navigationHide ? null : navigation || React.createElement(React.Fragment, null);\n  //navigation must not be open if navigationHide is true\n  const resolvedNavigationOpen = !!resolvedNavigation && navigationOpen;\n  const {\n    maxDrawerSize,\n    maxSplitPanelSize,\n    splitPanelForcedPosition,\n    splitPanelPosition,\n    maxGlobalDrawersSizes,\n    resizableSpaceAvailable\n  } = computeHorizontalLayout({\n    activeDrawerSize: activeDrawer ? activeDrawerSize : 0,\n    splitPanelSize,\n    minContentWidth,\n    navigationOpen: resolvedNavigationOpen,\n    navigationWidth,\n    placement,\n    splitPanelOpen,\n    splitPanelPosition: splitPanelPreferences === null || splitPanelPreferences === void 0 ? void 0 : splitPanelPreferences.position,\n    isMobile,\n    activeGlobalDrawersSizes\n  });\n  const {\n    ref: intersectionObserverRef,\n    isIntersecting\n  } = useIntersectionObserver({\n    initialState: true\n  });\n  const {\n    registered,\n    toolbarProps\n  } = useMultiAppLayout({\n    forceDeduplicationType,\n    ariaLabels: ariaLabelsWithDrawers,\n    navigation: resolvedNavigation,\n    navigationOpen: resolvedNavigationOpen,\n    onNavigationToggle,\n    navigationFocusRef: navigationFocusControl.refs.toggle,\n    breadcrumbs,\n    activeDrawerId: (_c = activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.id) !== null && _c !== void 0 ? _c : null,\n    // only pass it down if there are non-empty drawers or tools\n    drawers: (drawers === null || drawers === void 0 ? void 0 : drawers.length) || !toolsHide ? drawers : undefined,\n    globalDrawersFocusControl,\n    globalDrawers: (globalDrawers === null || globalDrawers === void 0 ? void 0 : globalDrawers.length) ? globalDrawers : undefined,\n    activeGlobalDrawersIds,\n    onActiveGlobalDrawersChange,\n    onActiveDrawerChange: onActiveDrawerChangeHandler,\n    drawersFocusRef: drawersFocusControl.refs.toggle,\n    splitPanel,\n    splitPanelToggleProps: Object.assign(Object.assign({}, splitPanelToggleConfig), {\n      active: splitPanelOpen,\n      controlId: splitPanelControlId,\n      position: splitPanelPosition\n    }),\n    splitPanelFocusRef: splitPanelFocusControl.refs.toggle,\n    onSplitPanelToggle: onSplitPanelToggleHandler\n  }, isIntersecting);\n  const hasToolbar = !embeddedViewMode && !!toolbarProps;\n  const discoveredBreadcrumbs = useGetGlobalBreadcrumbs(hasToolbar && !breadcrumbs);\n  const verticalOffsets = computeVerticalLayout({\n    topOffset: placement.insetBlockStart,\n    hasVisibleToolbar: hasToolbar && toolbarState !== 'hide',\n    notificationsHeight: notificationsHeight !== null && notificationsHeight !== void 0 ? notificationsHeight : 0,\n    toolbarHeight: toolbarHeight !== null && toolbarHeight !== void 0 ? toolbarHeight : 0,\n    stickyNotifications: resolvedStickyNotifications\n  });\n  const appLayoutInternals = {\n    ariaLabels: ariaLabelsWithDrawers,\n    headerVariant,\n    isMobile,\n    breadcrumbs,\n    discoveredBreadcrumbs,\n    stickyNotifications: resolvedStickyNotifications,\n    navigationOpen: resolvedNavigationOpen,\n    navigation: resolvedNavigation,\n    navigationFocusControl,\n    activeDrawer,\n    activeDrawerSize,\n    minDrawerSize,\n    maxDrawerSize,\n    minGlobalDrawersSizes,\n    maxGlobalDrawersSizes,\n    drawers: drawers,\n    globalDrawers,\n    activeGlobalDrawers,\n    activeGlobalDrawersIds,\n    activeGlobalDrawersSizes,\n    onActiveGlobalDrawersChange,\n    drawersFocusControl,\n    globalDrawersFocusControl,\n    splitPanelPosition,\n    splitPanelToggleConfig,\n    splitPanelOpen,\n    splitPanelControlId,\n    splitPanelFocusControl,\n    placement,\n    toolbarState,\n    setToolbarState,\n    verticalOffsets,\n    drawersOpenQueue,\n    setToolbarHeight,\n    setNotificationsHeight,\n    onSplitPanelToggle: onSplitPanelToggleHandler,\n    onNavigationToggle,\n    onActiveDrawerChange: onActiveDrawerChangeHandler,\n    onActiveDrawerResize,\n    splitPanelAnimationDisabled\n  };\n  const splitPanelInternals = {\n    bottomOffset: 0,\n    getMaxHeight: () => {\n      const availableHeight = document.documentElement.clientHeight - placement.insetBlockStart - placement.insetBlockEnd;\n      // If the page is likely zoomed in at 200%, allow the split panel to fill the content area.\n      return availableHeight < 400 ? availableHeight - 40 : availableHeight - 250;\n    },\n    maxWidth: maxSplitPanelSize,\n    isForcedPosition: splitPanelForcedPosition,\n    isOpen: splitPanelOpen,\n    leftOffset: 0,\n    onPreferencesChange: onSplitPanelPreferencesChangeHandler,\n    onResize: onSplitPanelResizeHandler,\n    onToggle: onSplitPanelToggleHandler,\n    position: splitPanelPosition,\n    reportSize: size => setSplitPanelReportedSize(size),\n    reportHeaderHeight: size => setSplitPanelHeaderBlockSize(size),\n    headerHeight: splitPanelHeaderBlockSize,\n    rightOffset: 0,\n    size: splitPanelSize,\n    topOffset: 0,\n    setSplitPanelToggle: setSplitPanelToggleConfig,\n    refs: splitPanelFocusControl.refs\n  };\n  const closeFirstDrawer = useStableCallback(() => {\n    const drawerToClose = drawersOpenQueue[drawersOpenQueue.length - 1];\n    if (activeDrawer && (activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.id) === drawerToClose) {\n      onActiveDrawerChange(null, {\n        initiatedByUserAction: true\n      });\n    } else if (activeGlobalDrawersIds.includes(drawerToClose)) {\n      onActiveGlobalDrawersChange(drawerToClose, {\n        initiatedByUserAction: true\n      });\n    }\n  });\n  useEffect(() => {\n    // Close navigation drawer on mobile so that the main content is visible\n    if (isMobile) {\n      onNavigationToggle(false);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isMobile]);\n  const getTotalActiveDrawersMinSize = () => {\n    var _a;\n    const combinedDrawers = [...(drawers || []), ...globalDrawers];\n    let result = activeGlobalDrawersIds.map(activeDrawerId => {\n      var _a, _b;\n      return Math.min((_b = (_a = combinedDrawers.find(drawer => drawer.id === activeDrawerId)) === null || _a === void 0 ? void 0 : _a.defaultSize) !== null && _b !== void 0 ? _b : MIN_DRAWER_SIZE, MIN_DRAWER_SIZE);\n    }).reduce((acc, curr) => acc + curr, 0);\n    if (activeDrawer) {\n      result += Math.min((_a = activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.defaultSize) !== null && _a !== void 0 ? _a : MIN_DRAWER_SIZE, MIN_DRAWER_SIZE);\n    }\n    return result;\n  };\n  const totalActiveDrawersMinSize = getTotalActiveDrawersMinSize();\n  useEffect(() => {\n    if (isMobile) {\n      return;\n    }\n    const activeNavigationWidth = !navigationHide && navigationOpen ? navigationWidth : 0;\n    const scrollWidth = activeNavigationWidth + CONTENT_PADDING + totalActiveDrawersMinSize;\n    const hasHorizontalScroll = scrollWidth > placement.inlineSize;\n    if (hasHorizontalScroll) {\n      if (!navigationHide && navigationOpen) {\n        onNavigationToggle(false);\n        return;\n      }\n      closeFirstDrawer();\n    }\n  }, [totalActiveDrawersMinSize, closeFirstDrawer, isMobile, navigationHide, navigationOpen, navigationWidth, onNavigationToggle, placement.inlineSize]);\n  /**\n   * Returns true if the AppLayout is nested\n   * Does not apply to iframe\n   */\n  const getIsNestedInAppLayout = element => {\n    var _a;\n    let currentElement = (_a = element === null || element === void 0 ? void 0 : element.parentElement) !== null && _a !== void 0 ? _a : null;\n    // this traverse is needed only for JSDOM\n    // in real browsers the globalVar will be propagated to all descendants and this loops exits after initial iteration\n    while (currentElement) {\n      if (getComputedStyle(currentElement).getPropertyValue(globalVars.stickyVerticalTopOffset)) {\n        return true;\n      }\n      currentElement = currentElement.parentElement;\n    }\n    return false;\n  };\n  useLayoutEffect(() => {\n    if (!hasToolbar) {\n      setIsNested(getIsNestedInAppLayout(rootRef.current));\n    }\n  }, [hasToolbar]);\n  return React.createElement(AppLayoutVisibilityContext.Provider, {\n    value: isIntersecting\n  }, !hasToolbar && breadcrumbs ? React.createElement(ScreenreaderOnly, null, breadcrumbs) : null, React.createElement(SkeletonLayout, {\n    ref: useMergeRefs(intersectionObserverRef, rootRef),\n    isNested: isNested,\n    style: Object.assign(Object.assign({\n      paddingBlockEnd: splitPanelPosition === 'bottom' ? splitPanelOpen ? splitPanelReportedSize : splitPanelHeaderBlockSize : ''\n    }, hasToolbar || !isNested ? {\n      [globalVars.stickyVerticalTopOffset]: `${verticalOffsets.header}px`,\n      [globalVars.stickyVerticalBottomOffset]: `${placement.insetBlockEnd}px`\n    } : {}), !isMobile ? {\n      minWidth: `${minContentWidth}px`\n    } : {}),\n    toolbar: hasToolbar && React.createElement(AppLayoutToolbar, {\n      appLayoutInternals: appLayoutInternals,\n      toolbarProps: toolbarProps\n    }),\n    notifications: notifications && React.createElement(AppLayoutNotifications, {\n      appLayoutInternals: appLayoutInternals\n    }, notifications),\n    headerVariant: headerVariant,\n    contentHeader: contentHeader,\n    // delay rendering the content until registration of this instance is complete\n    content: registered ? content : null,\n    navigation: resolvedNavigation && React.createElement(AppLayoutNavigation, {\n      appLayoutInternals: appLayoutInternals\n    }),\n    navigationOpen: resolvedNavigationOpen,\n    navigationWidth: navigationWidth,\n    navigationAnimationDisabled: navigationAnimationDisabled,\n    tools: drawers && drawers.length > 0 && React.createElement(AppLayoutDrawer, {\n      appLayoutInternals: appLayoutInternals\n    }),\n    globalTools: React.createElement(ActiveDrawersContext.Provider, {\n      value: activeGlobalDrawersIds\n    }, React.createElement(AppLayoutGlobalDrawers, {\n      appLayoutInternals: appLayoutInternals\n    })),\n    globalToolsOpen: !!activeGlobalDrawersIds.length,\n    toolsOpen: !!activeDrawer,\n    toolsWidth: activeDrawerSize,\n    sideSplitPanel: splitPanelPosition === 'side' && React.createElement(AppLayoutSplitPanelSide, {\n      appLayoutInternals: appLayoutInternals,\n      splitPanelInternals: splitPanelInternals\n    }, splitPanel),\n    bottomSplitPanel: splitPanelPosition === 'bottom' && React.createElement(AppLayoutSplitPanelBottom, {\n      appLayoutInternals: appLayoutInternals,\n      splitPanelInternals: splitPanelInternals\n    }, splitPanel),\n    splitPanelOpen: splitPanelOpen,\n    placement: placement,\n    contentType: contentType,\n    maxContentWidth: maxContentWidth,\n    disableContentPaddings: disableContentPaddings\n  }));\n});\nexport default AppLayoutVisualRefreshToolbar;","map":{"version":3,"names":["React","useEffect","useImperativeHandle","useLayoutEffect","useRef","useState","useStableCallback","ScreenreaderOnly","fireNonCancelableEvent","useControllable","useIntersectionObserver","useMergeRefs","useMobile","useUniqueId","useGetGlobalBreadcrumbs","globalVars","getSplitPanelDefaultSize","MIN_DRAWER_SIZE","useDrawers","useFocusControl","useMultipleFocusControl","useSplitPanelFocusControl","ActiveDrawersContext","computeHorizontalLayout","computeVerticalLayout","CONTENT_PADDING","AppLayoutVisibilityContext","AppLayoutDrawer","AppLayoutGlobalDrawers","AppLayoutNavigation","AppLayoutNotifications","AppLayoutSplitPanelBottom","AppLayoutSplitPanelSide","AppLayoutToolbar","useMultiAppLayout","SkeletonLayout","AppLayoutVisualRefreshToolbar","forwardRef","_a","ariaLabels","contentHeader","content","navigationOpen","navigationWidth","navigation","navigationHide","onNavigationChange","tools","toolsOpen","controlledToolsOpen","onToolsChange","toolsHide","toolsWidth","contentType","headerVariant","breadcrumbs","notifications","stickyNotifications","splitPanelPreferences","controlledSplitPanelPreferences","splitPanelOpen","controlledSplitPanelOpen","splitPanel","splitPanelSize","controlledSplitPanelSize","onSplitPanelToggle","onSplitPanelResize","onSplitPanelPreferencesChange","disableContentPaddings","minContentWidth","maxContentWidth","placement","rest","__rest","isMobile","__embeddedViewMode","embeddedViewMode","__forceDeduplicationType","forceDeduplicationType","splitPanelControlId","toolbarState","setToolbarState","toolbarHeight","setToolbarHeight","notificationsHeight","setNotificationsHeight","navigationAnimationDisabled","setNavigationAnimationDisabled","splitPanelAnimationDisabled","setSplitPanelAnimationDisabled","isNested","setIsNested","rootRef","setToolsOpen","componentName","controlledProp","changeHandler","onToolsToggle","open","drawersFocusControl","setFocus","onGlobalDrawerFocus","drawerId","globalDrawersFocusControl","force","onAddNewActiveDrawer","activeDrawer","drawers","find","drawer","id","combinedDrawers","globalDrawers","newDrawer","newDrawerSize","Math","min","_b","defaultSize","drawerSizes","availableSpaceForNewDrawer","resizableSpaceAvailable","totalActiveDrawersMinSize","closeFirstDrawer","minDrawerSize","minGlobalDrawersSizes","activeDrawerSize","ariaLabelsWithDrawers","activeGlobalDrawers","activeGlobalDrawersIds","activeGlobalDrawersSizes","drawersOpenQueue","onActiveDrawerChange","onActiveDrawerResize","onActiveGlobalDrawersChange","Object","assign","onActiveDrawerChangeHandler","params","initiatedByUserAction","setSplitPanelOpen","onSplitPanelToggleHandler","splitPanelFocusControl","setLastInteraction","type","setSplitPanelPreferences","undefined","onSplitPanelPreferencesChangeHandler","detail","setSplitPanelSize","position","splitPanelReportedSize","setSplitPanelReportedSize","splitPanelHeaderBlockSize","setSplitPanelHeaderBlockSize","onSplitPanelResizeHandler","size","splitPanelToggleConfig","setSplitPanelToggleConfig","ariaLabel","displayed","navigationFocusControl","onNavigationToggle","closeNavigationIfNecessary","openTools","focusToolsClose","focusActiveDrawer","focusSplitPanel","refs","slider","current","focus","resolvedStickyNotifications","resolvedNavigation","createElement","Fragment","resolvedNavigationOpen","maxDrawerSize","maxSplitPanelSize","splitPanelForcedPosition","splitPanelPosition","maxGlobalDrawersSizes","ref","intersectionObserverRef","isIntersecting","initialState","registered","toolbarProps","navigationFocusRef","toggle","activeDrawerId","_c","length","drawersFocusRef","splitPanelToggleProps","active","controlId","splitPanelFocusRef","hasToolbar","discoveredBreadcrumbs","verticalOffsets","topOffset","insetBlockStart","hasVisibleToolbar","appLayoutInternals","splitPanelInternals","bottomOffset","getMaxHeight","availableHeight","document","documentElement","clientHeight","insetBlockEnd","maxWidth","isForcedPosition","isOpen","leftOffset","onPreferencesChange","onResize","onToggle","reportSize","reportHeaderHeight","headerHeight","rightOffset","setSplitPanelToggle","drawerToClose","includes","getTotalActiveDrawersMinSize","result","map","reduce","acc","curr","activeNavigationWidth","scrollWidth","hasHorizontalScroll","inlineSize","getIsNestedInAppLayout","element","currentElement","parentElement","getComputedStyle","getPropertyValue","stickyVerticalTopOffset","Provider","value","style","paddingBlockEnd","header","stickyVerticalBottomOffset","minWidth","toolbar","globalTools","globalToolsOpen","sideSplitPanel","bottomSplitPanel"],"sources":["C:\\Users\\tanne\\Desktop\\Bright Path Analytics\\Education-Planning-Assistant-App\\frontend\\node_modules\\src\\app-layout\\visual-refresh-toolbar\\index.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useEffect, useImperativeHandle, useLayoutEffect, useRef, useState } from 'react';\n\nimport { useStableCallback } from '@cloudscape-design/component-toolkit/internal';\n\nimport ScreenreaderOnly from '../../internal/components/screenreader-only';\nimport { SplitPanelSideToggleProps } from '../../internal/context/split-panel-context';\nimport { fireNonCancelableEvent } from '../../internal/events';\nimport { useControllable } from '../../internal/hooks/use-controllable';\nimport { useIntersectionObserver } from '../../internal/hooks/use-intersection-observer';\nimport { useMergeRefs } from '../../internal/hooks/use-merge-refs';\nimport { useMobile } from '../../internal/hooks/use-mobile';\nimport { useUniqueId } from '../../internal/hooks/use-unique-id';\nimport { useGetGlobalBreadcrumbs } from '../../internal/plugins/helpers/use-global-breadcrumbs';\nimport globalVars from '../../internal/styles/global-vars';\nimport { getSplitPanelDefaultSize } from '../../split-panel/utils/size-utils';\nimport { AppLayoutProps, AppLayoutPropsWithDefaults } from '../interfaces';\nimport { SplitPanelProviderProps } from '../split-panel';\nimport { MIN_DRAWER_SIZE, OnChangeParams, useDrawers } from '../utils/use-drawers';\nimport { useFocusControl, useMultipleFocusControl } from '../utils/use-focus-control';\nimport { useSplitPanelFocusControl } from '../utils/use-split-panel-focus-control';\nimport { ActiveDrawersContext } from '../utils/visibility-context';\nimport { computeHorizontalLayout, computeVerticalLayout, CONTENT_PADDING } from './compute-layout';\nimport { AppLayoutVisibilityContext } from './contexts';\nimport { AppLayoutInternals } from './interfaces';\nimport {\n  AppLayoutDrawer,\n  AppLayoutGlobalDrawers,\n  AppLayoutNavigation,\n  AppLayoutNotifications,\n  AppLayoutSplitPanelBottom,\n  AppLayoutSplitPanelSide,\n  AppLayoutToolbar,\n} from './internal';\nimport { useMultiAppLayout } from './multi-layout';\nimport { SkeletonLayout } from './skeleton';\n\nconst AppLayoutVisualRefreshToolbar = React.forwardRef<AppLayoutProps.Ref, AppLayoutPropsWithDefaults>(\n  (\n    {\n      ariaLabels,\n      contentHeader,\n      content,\n      navigationOpen,\n      navigationWidth,\n      navigation,\n      navigationHide,\n      onNavigationChange,\n      tools,\n      toolsOpen: controlledToolsOpen,\n      onToolsChange,\n      toolsHide,\n      toolsWidth,\n      contentType,\n      headerVariant,\n      breadcrumbs,\n      notifications,\n      stickyNotifications,\n      splitPanelPreferences: controlledSplitPanelPreferences,\n      splitPanelOpen: controlledSplitPanelOpen,\n      splitPanel,\n      splitPanelSize: controlledSplitPanelSize,\n      onSplitPanelToggle,\n      onSplitPanelResize,\n      onSplitPanelPreferencesChange,\n      disableContentPaddings,\n      minContentWidth,\n      maxContentWidth,\n      placement,\n      ...rest\n    },\n    forwardRef\n  ) => {\n    const isMobile = useMobile();\n    const { __embeddedViewMode: embeddedViewMode, __forceDeduplicationType: forceDeduplicationType } = rest as any;\n    const splitPanelControlId = useUniqueId('split-panel');\n    const [toolbarState, setToolbarState] = useState<'show' | 'hide'>('show');\n    const [toolbarHeight, setToolbarHeight] = useState(0);\n    const [notificationsHeight, setNotificationsHeight] = useState(0);\n    const [navigationAnimationDisabled, setNavigationAnimationDisabled] = useState(true);\n    const [splitPanelAnimationDisabled, setSplitPanelAnimationDisabled] = useState(true);\n    const [isNested, setIsNested] = useState(false);\n    const rootRef = useRef<HTMLDivElement>(null);\n\n    const [toolsOpen = false, setToolsOpen] = useControllable(controlledToolsOpen, onToolsChange, false, {\n      componentName: 'AppLayout',\n      controlledProp: 'toolsOpen',\n      changeHandler: 'onToolsChange',\n    });\n    const onToolsToggle = (open: boolean) => {\n      setToolsOpen(open);\n      drawersFocusControl.setFocus();\n      fireNonCancelableEvent(onToolsChange, { open });\n    };\n\n    const onGlobalDrawerFocus = (drawerId: string, open: boolean) => {\n      globalDrawersFocusControl.setFocus({ force: true, drawerId, open });\n    };\n\n    const onAddNewActiveDrawer = (drawerId: string) => {\n      // If a local drawer is already open, and we attempt to open a new one,\n      // it will replace the existing one instead of opening an additional drawer,\n      // since only one local drawer is supported. Therefore, layout calculations are not necessary.\n      if (activeDrawer && drawers?.find(drawer => drawer.id === drawerId)) {\n        return;\n      }\n      // get the size of drawerId. it could be either local or global drawer\n      const combinedDrawers = [...(drawers || []), ...globalDrawers];\n      const newDrawer = combinedDrawers.find(drawer => drawer.id === drawerId);\n      if (!newDrawer) {\n        return;\n      }\n      const newDrawerSize = Math.min(\n        newDrawer.defaultSize ?? drawerSizes[drawerId] ?? MIN_DRAWER_SIZE,\n        MIN_DRAWER_SIZE\n      );\n      //   check if the active drawers could be resized to fit the new drawers\n      //   to do this, we need to take all active drawers, sum up their min sizes, truncate it from resizableSpaceAvailable\n      //   and compare a given number with the new drawer id min size\n\n      // the total size of all global drawers resized to their min size\n      const availableSpaceForNewDrawer = resizableSpaceAvailable - totalActiveDrawersMinSize;\n      if (availableSpaceForNewDrawer >= newDrawerSize) {\n        return;\n      }\n\n      // now we made sure we cannot accommodate the new drawer with existing ones\n      closeFirstDrawer();\n    };\n\n    const {\n      drawers,\n      activeDrawer,\n      minDrawerSize,\n      minGlobalDrawersSizes,\n      activeDrawerSize,\n      ariaLabelsWithDrawers,\n      globalDrawers,\n      activeGlobalDrawers,\n      activeGlobalDrawersIds,\n      activeGlobalDrawersSizes,\n      drawerSizes,\n      drawersOpenQueue,\n      onActiveDrawerChange,\n      onActiveDrawerResize,\n      onActiveGlobalDrawersChange,\n    } = useDrawers({ ...rest, onGlobalDrawerFocus, onAddNewActiveDrawer }, ariaLabels, {\n      ariaLabels,\n      toolsHide,\n      toolsOpen,\n      tools,\n      toolsWidth,\n      onToolsToggle,\n    });\n\n    const onActiveDrawerChangeHandler = (\n      drawerId: string | null,\n      params: OnChangeParams = { initiatedByUserAction: true }\n    ) => {\n      onActiveDrawerChange(drawerId, params);\n      drawersFocusControl.setFocus();\n    };\n\n    const [splitPanelOpen = false, setSplitPanelOpen] = useControllable(\n      controlledSplitPanelOpen,\n      onSplitPanelToggle,\n      false,\n      {\n        componentName: 'AppLayout',\n        controlledProp: 'splitPanelOpen',\n        changeHandler: 'onSplitPanelToggle',\n      }\n    );\n\n    const onSplitPanelToggleHandler = () => {\n      setSplitPanelAnimationDisabled(false);\n      setSplitPanelOpen(!splitPanelOpen);\n      splitPanelFocusControl.setLastInteraction({ type: splitPanelOpen ? 'close' : 'open' });\n      fireNonCancelableEvent(onSplitPanelToggle, { open: !splitPanelOpen });\n    };\n\n    const [splitPanelPreferences, setSplitPanelPreferences] = useControllable(\n      controlledSplitPanelPreferences,\n      onSplitPanelPreferencesChange,\n      undefined,\n      {\n        componentName: 'AppLayout',\n        controlledProp: 'splitPanelPreferences',\n        changeHandler: 'onSplitPanelPreferencesChange',\n      }\n    );\n\n    const onSplitPanelPreferencesChangeHandler = (detail: AppLayoutProps.SplitPanelPreferences) => {\n      setSplitPanelPreferences(detail);\n      splitPanelFocusControl.setLastInteraction({ type: 'position' });\n      fireNonCancelableEvent(onSplitPanelPreferencesChange, detail);\n    };\n\n    const [splitPanelSize = 0, setSplitPanelSize] = useControllable(\n      controlledSplitPanelSize,\n      onSplitPanelResize,\n      getSplitPanelDefaultSize(splitPanelPreferences?.position ?? 'bottom'),\n      { componentName: 'AppLayout', controlledProp: 'splitPanelSize', changeHandler: 'onSplitPanelResize' }\n    );\n\n    const [splitPanelReportedSize, setSplitPanelReportedSize] = useState(0);\n    const [splitPanelHeaderBlockSize, setSplitPanelHeaderBlockSize] = useState(0);\n\n    const onSplitPanelResizeHandler = (size: number) => {\n      setSplitPanelSize(size);\n      fireNonCancelableEvent(onSplitPanelResize, { size });\n    };\n\n    const [splitPanelToggleConfig, setSplitPanelToggleConfig] = useState<SplitPanelSideToggleProps>({\n      ariaLabel: undefined,\n      displayed: false,\n    });\n\n    const globalDrawersFocusControl = useMultipleFocusControl(true, activeGlobalDrawersIds);\n    const drawersFocusControl = useFocusControl(!!activeDrawer?.id, true, activeDrawer?.id);\n    const navigationFocusControl = useFocusControl(navigationOpen);\n    const splitPanelFocusControl = useSplitPanelFocusControl([splitPanelPreferences, splitPanelOpen]);\n\n    const onNavigationToggle = useStableCallback((open: boolean) => {\n      setNavigationAnimationDisabled(false);\n      navigationFocusControl.setFocus();\n      fireNonCancelableEvent(onNavigationChange, { open });\n    });\n\n    useImperativeHandle(forwardRef, () => ({\n      closeNavigationIfNecessary: () => isMobile && onNavigationToggle(false),\n      openTools: () => onToolsToggle(true),\n      focusToolsClose: () => drawersFocusControl.setFocus(true),\n      focusActiveDrawer: () => drawersFocusControl.setFocus(true),\n      focusSplitPanel: () => splitPanelFocusControl.refs.slider.current?.focus(),\n    }));\n\n    const resolvedStickyNotifications = !!stickyNotifications && !isMobile;\n    //navigation must be null if hidden so toolbar knows to hide the toggle button\n    const resolvedNavigation = navigationHide ? null : navigation || <></>;\n    //navigation must not be open if navigationHide is true\n    const resolvedNavigationOpen = !!resolvedNavigation && navigationOpen;\n    const {\n      maxDrawerSize,\n      maxSplitPanelSize,\n      splitPanelForcedPosition,\n      splitPanelPosition,\n      maxGlobalDrawersSizes,\n      resizableSpaceAvailable,\n    } = computeHorizontalLayout({\n      activeDrawerSize: activeDrawer ? activeDrawerSize : 0,\n      splitPanelSize,\n      minContentWidth,\n      navigationOpen: resolvedNavigationOpen,\n      navigationWidth,\n      placement,\n      splitPanelOpen,\n      splitPanelPosition: splitPanelPreferences?.position,\n      isMobile,\n      activeGlobalDrawersSizes,\n    });\n\n    const { ref: intersectionObserverRef, isIntersecting } = useIntersectionObserver({ initialState: true });\n    const { registered, toolbarProps } = useMultiAppLayout(\n      {\n        forceDeduplicationType,\n        ariaLabels: ariaLabelsWithDrawers,\n        navigation: resolvedNavigation,\n        navigationOpen: resolvedNavigationOpen,\n        onNavigationToggle,\n        navigationFocusRef: navigationFocusControl.refs.toggle,\n        breadcrumbs,\n        activeDrawerId: activeDrawer?.id ?? null,\n        // only pass it down if there are non-empty drawers or tools\n        drawers: drawers?.length || !toolsHide ? drawers : undefined,\n        globalDrawersFocusControl,\n        globalDrawers: globalDrawers?.length ? globalDrawers : undefined,\n        activeGlobalDrawersIds,\n        onActiveGlobalDrawersChange,\n        onActiveDrawerChange: onActiveDrawerChangeHandler,\n        drawersFocusRef: drawersFocusControl.refs.toggle,\n        splitPanel,\n        splitPanelToggleProps: {\n          ...splitPanelToggleConfig,\n          active: splitPanelOpen,\n          controlId: splitPanelControlId,\n          position: splitPanelPosition,\n        },\n        splitPanelFocusRef: splitPanelFocusControl.refs.toggle,\n        onSplitPanelToggle: onSplitPanelToggleHandler,\n      },\n      isIntersecting\n    );\n\n    const hasToolbar = !embeddedViewMode && !!toolbarProps;\n    const discoveredBreadcrumbs = useGetGlobalBreadcrumbs(hasToolbar && !breadcrumbs);\n\n    const verticalOffsets = computeVerticalLayout({\n      topOffset: placement.insetBlockStart,\n      hasVisibleToolbar: hasToolbar && toolbarState !== 'hide',\n      notificationsHeight: notificationsHeight ?? 0,\n      toolbarHeight: toolbarHeight ?? 0,\n      stickyNotifications: resolvedStickyNotifications,\n    });\n\n    const appLayoutInternals: AppLayoutInternals = {\n      ariaLabels: ariaLabelsWithDrawers,\n      headerVariant,\n      isMobile,\n      breadcrumbs,\n      discoveredBreadcrumbs,\n      stickyNotifications: resolvedStickyNotifications,\n      navigationOpen: resolvedNavigationOpen,\n      navigation: resolvedNavigation,\n      navigationFocusControl,\n      activeDrawer,\n      activeDrawerSize,\n      minDrawerSize,\n      maxDrawerSize,\n      minGlobalDrawersSizes,\n      maxGlobalDrawersSizes,\n      drawers: drawers!,\n      globalDrawers,\n      activeGlobalDrawers,\n      activeGlobalDrawersIds,\n      activeGlobalDrawersSizes,\n      onActiveGlobalDrawersChange,\n      drawersFocusControl,\n      globalDrawersFocusControl,\n      splitPanelPosition,\n      splitPanelToggleConfig,\n      splitPanelOpen,\n      splitPanelControlId,\n      splitPanelFocusControl,\n      placement,\n      toolbarState,\n      setToolbarState,\n      verticalOffsets,\n      drawersOpenQueue,\n      setToolbarHeight,\n      setNotificationsHeight,\n      onSplitPanelToggle: onSplitPanelToggleHandler,\n      onNavigationToggle,\n      onActiveDrawerChange: onActiveDrawerChangeHandler,\n      onActiveDrawerResize,\n      splitPanelAnimationDisabled,\n    };\n\n    const splitPanelInternals: SplitPanelProviderProps = {\n      bottomOffset: 0,\n      getMaxHeight: () => {\n        const availableHeight =\n          document.documentElement.clientHeight - placement.insetBlockStart - placement.insetBlockEnd;\n        // If the page is likely zoomed in at 200%, allow the split panel to fill the content area.\n        return availableHeight < 400 ? availableHeight - 40 : availableHeight - 250;\n      },\n      maxWidth: maxSplitPanelSize,\n      isForcedPosition: splitPanelForcedPosition,\n      isOpen: splitPanelOpen,\n      leftOffset: 0,\n      onPreferencesChange: onSplitPanelPreferencesChangeHandler,\n      onResize: onSplitPanelResizeHandler,\n      onToggle: onSplitPanelToggleHandler,\n      position: splitPanelPosition,\n      reportSize: size => setSplitPanelReportedSize(size),\n      reportHeaderHeight: size => setSplitPanelHeaderBlockSize(size),\n      headerHeight: splitPanelHeaderBlockSize,\n      rightOffset: 0,\n      size: splitPanelSize,\n      topOffset: 0,\n      setSplitPanelToggle: setSplitPanelToggleConfig,\n      refs: splitPanelFocusControl.refs,\n    };\n\n    const closeFirstDrawer = useStableCallback(() => {\n      const drawerToClose = drawersOpenQueue[drawersOpenQueue.length - 1];\n      if (activeDrawer && activeDrawer?.id === drawerToClose) {\n        onActiveDrawerChange(null, { initiatedByUserAction: true });\n      } else if (activeGlobalDrawersIds.includes(drawerToClose)) {\n        onActiveGlobalDrawersChange(drawerToClose, { initiatedByUserAction: true });\n      }\n    });\n\n    useEffect(() => {\n      // Close navigation drawer on mobile so that the main content is visible\n      if (isMobile) {\n        onNavigationToggle(false);\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [isMobile]);\n\n    const getTotalActiveDrawersMinSize = () => {\n      const combinedDrawers = [...(drawers || []), ...globalDrawers];\n      let result = activeGlobalDrawersIds\n        .map(activeDrawerId =>\n          Math.min(\n            combinedDrawers.find(drawer => drawer.id === activeDrawerId)?.defaultSize ?? MIN_DRAWER_SIZE,\n            MIN_DRAWER_SIZE\n          )\n        )\n        .reduce((acc, curr) => acc + curr, 0);\n      if (activeDrawer) {\n        result += Math.min(activeDrawer?.defaultSize ?? MIN_DRAWER_SIZE, MIN_DRAWER_SIZE);\n      }\n\n      return result;\n    };\n\n    const totalActiveDrawersMinSize = getTotalActiveDrawersMinSize();\n\n    useEffect(() => {\n      if (isMobile) {\n        return;\n      }\n\n      const activeNavigationWidth = !navigationHide && navigationOpen ? navigationWidth : 0;\n      const scrollWidth = activeNavigationWidth + CONTENT_PADDING + totalActiveDrawersMinSize;\n      const hasHorizontalScroll = scrollWidth > placement.inlineSize;\n      if (hasHorizontalScroll) {\n        if (!navigationHide && navigationOpen) {\n          onNavigationToggle(false);\n          return;\n        }\n\n        closeFirstDrawer();\n      }\n    }, [\n      totalActiveDrawersMinSize,\n      closeFirstDrawer,\n      isMobile,\n      navigationHide,\n      navigationOpen,\n      navigationWidth,\n      onNavigationToggle,\n      placement.inlineSize,\n    ]);\n\n    /**\n     * Returns true if the AppLayout is nested\n     * Does not apply to iframe\n     */\n    const getIsNestedInAppLayout = (element: HTMLElement | null): boolean => {\n      let currentElement: Element | null = element?.parentElement ?? null;\n\n      // this traverse is needed only for JSDOM\n      // in real browsers the globalVar will be propagated to all descendants and this loops exits after initial iteration\n      while (currentElement) {\n        if (getComputedStyle(currentElement).getPropertyValue(globalVars.stickyVerticalTopOffset)) {\n          return true;\n        }\n        currentElement = currentElement.parentElement;\n      }\n\n      return false;\n    };\n\n    useLayoutEffect(() => {\n      if (!hasToolbar) {\n        setIsNested(getIsNestedInAppLayout(rootRef.current));\n      }\n    }, [hasToolbar]);\n\n    return (\n      <AppLayoutVisibilityContext.Provider value={isIntersecting}>\n        {/* Rendering a hidden copy of breadcrumbs to trigger their deduplication */}\n        {!hasToolbar && breadcrumbs ? <ScreenreaderOnly>{breadcrumbs}</ScreenreaderOnly> : null}\n        <SkeletonLayout\n          ref={useMergeRefs(intersectionObserverRef, rootRef)}\n          isNested={isNested}\n          style={{\n            paddingBlockEnd:\n              splitPanelPosition === 'bottom'\n                ? splitPanelOpen\n                  ? splitPanelReportedSize\n                  : splitPanelHeaderBlockSize\n                : '',\n            ...(hasToolbar || !isNested\n              ? {\n                  [globalVars.stickyVerticalTopOffset]: `${verticalOffsets.header}px`,\n                  [globalVars.stickyVerticalBottomOffset]: `${placement.insetBlockEnd}px`,\n                }\n              : {}),\n            ...(!isMobile ? { minWidth: `${minContentWidth}px` } : {}),\n          }}\n          toolbar={\n            hasToolbar && <AppLayoutToolbar appLayoutInternals={appLayoutInternals} toolbarProps={toolbarProps} />\n          }\n          notifications={\n            notifications && (\n              <AppLayoutNotifications appLayoutInternals={appLayoutInternals}>{notifications}</AppLayoutNotifications>\n            )\n          }\n          headerVariant={headerVariant}\n          contentHeader={contentHeader}\n          // delay rendering the content until registration of this instance is complete\n          content={registered ? content : null}\n          navigation={resolvedNavigation && <AppLayoutNavigation appLayoutInternals={appLayoutInternals} />}\n          navigationOpen={resolvedNavigationOpen}\n          navigationWidth={navigationWidth}\n          navigationAnimationDisabled={navigationAnimationDisabled}\n          tools={drawers && drawers.length > 0 && <AppLayoutDrawer appLayoutInternals={appLayoutInternals} />}\n          globalTools={\n            <ActiveDrawersContext.Provider value={activeGlobalDrawersIds}>\n              <AppLayoutGlobalDrawers appLayoutInternals={appLayoutInternals} />\n            </ActiveDrawersContext.Provider>\n          }\n          globalToolsOpen={!!activeGlobalDrawersIds.length}\n          toolsOpen={!!activeDrawer}\n          toolsWidth={activeDrawerSize}\n          sideSplitPanel={\n            splitPanelPosition === 'side' && (\n              <AppLayoutSplitPanelSide\n                appLayoutInternals={appLayoutInternals}\n                splitPanelInternals={splitPanelInternals}\n              >\n                {splitPanel}\n              </AppLayoutSplitPanelSide>\n            )\n          }\n          bottomSplitPanel={\n            splitPanelPosition === 'bottom' && (\n              <AppLayoutSplitPanelBottom\n                appLayoutInternals={appLayoutInternals}\n                splitPanelInternals={splitPanelInternals}\n              >\n                {splitPanel}\n              </AppLayoutSplitPanelBottom>\n            )\n          }\n          splitPanelOpen={splitPanelOpen}\n          placement={placement}\n          contentType={contentType}\n          maxContentWidth={maxContentWidth}\n          disableContentPaddings={disableContentPaddings}\n        />\n      </AppLayoutVisibilityContext.Provider>\n    );\n  }\n);\n\nexport default AppLayoutVisualRefreshToolbar;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}